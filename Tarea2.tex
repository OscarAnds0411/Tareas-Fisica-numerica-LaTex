\documentclass[10pt]{extarticle}

\usepackage[spanish]{babel}
\usepackage[T1]{fontenc}
\usepackage{lmodern,mathrsfs}
\usepackage{xparse}
\usepackage[inline,shortlabels]{enumitem}
\setlist{topsep=2pt,itemsep=2pt,parsep=0pt,partopsep=0pt}
\usepackage[dvipsnames]{xcolor}
\usepackage[utf8]{inputenc}
\usepackage[a4paper,top=0.5in,bottom=0.2in,left=0.5in,right=0.5in,footskip=0.3in,includefoot]{geometry}
\usepackage[most]{tcolorbox}
\tcbuselibrary{minted} % tcolorbox minted library, required to use the "minted" tcb listing engine (this library is not loaded by the option [most])
\usepackage{minted} % Allows input of raw code, such as Python code
\usepackage[colorlinks]{hyperref} % ALWAYS load this package LAST
\usepackage{listings}
\lstset{
    basicstyle=\ttfamily\footnotesize,
    keywordstyle=\color{blue},
    commentstyle=\color{gray},
    stringstyle=\color{green!40!black},
    showstringspaces=false,
    numbers=left,
    numberstyle=\tiny,
    frame=single,
    breaklines=true
}

% Custom tcolorbox style for Python code (not the code or the box it appears in, just the options for the box)
\tcbset{
    pythoncodebox/.style={
        enhanced jigsaw,breakable,
        colback=gray!10,colframe=gray!20!black,
        boxrule=1pt,top=2pt,bottom=2pt,left=2pt,right=2pt,
        sharp corners,before skip=10pt,after skip=10pt,
        attach boxed title to top left,
        boxed title style={empty,
            top=0pt,bottom=0pt,left=2pt,right=2pt,
            interior code={\fill[fill=tcbcolframe] (frame.south west)
                --([yshift=-4pt]frame.north west)
                to[out=90,in=180] ([xshift=4pt]frame.north west)
                --([xshift=-8pt]frame.north east)
                to[out=0,in=180] ([xshift=16pt]frame.south east)
                --cycle;
            }
        },
        title={#1}, % Argument of pythoncodebox specifies the title
        fonttitle=\sffamily\bfseries
    },
    pythoncodebox/.default={}, % Default is No title
    %%% Starred version has no frame %%%
    pythoncodebox*/.style={
        enhanced jigsaw,breakable,
        colback=gray!10,coltitle=gray!20!black,colbacktitle=tcbcolback,
        frame hidden,
        top=2pt,bottom=2pt,left=2pt,right=2pt,
        sharp corners,before skip=10pt,after skip=10pt,
        attach boxed title to top text left={yshift=-1mm},
        boxed title style={empty,
            top=0pt,bottom=0pt,left=2pt,right=2pt,
            interior code={\fill[fill=tcbcolback] (interior.south west)
                --([yshift=-4pt]interior.north west)
                to[out=90,in=180] ([xshift=4pt]interior.north west)
                --([xshift=-8pt]interior.north east)
                to[out=0,in=180] ([xshift=16pt]interior.south east)
                --cycle;
            }
        },
        title={#1}, % Argument of pythoncodebox specifies the title
        fonttitle=\sffamily\bfseries
    },
    pythoncodebox*/.default={}, % Default is No title
}

% Custom tcolorbox for Python code (not the code itself, just the box it appears in)
\newtcolorbox{pythonbox}[1][]{pythoncodebox=#1}
\newtcolorbox{pythonbox*}[1][]{pythoncodebox*=#1} % Starred version has no frame

% Custom minted environment for Python code, NOT using tcolorbox
\newminted{python}{autogobble,breaklines,mathescape}

% Custom tcblisting environment for Python code, using the "minted" tcb listing engine
% Adapted from https://tex.stackexchange.com/a/402096
\NewTCBListing{python}{ !O{} !D(){} !G{} }{
    listing engine=minted,
    listing only,
    pythoncodebox={#1}, % First argument specifies the title (if any)
    minted language=python,
    minted options/.expanded={
        autogobble,breaklines,mathescape,
        #2 % Second argument, delimited by (), denotes options for the minted environment
    },
    #3 % Third argument, delimited by {}, denotes options for the tcolorbox
}

%%% Starred version has no frame %%%
\NewTCBListing{python*}{ !O{} !D(){} !G{} }{
    listing engine=minted,
    listing only,
    pythoncodebox*={#1}, % First argument specifies the title (if any)
    minted language=python,
    minted options/.expanded={
        autogobble,breaklines,mathescape,
        #2 % Second argument, delimited by (), denotes options for the minted environment
    },
    #3 % Third argument, delimited by {}, denotes options for the tcolorbox
}

% verbbox environment, for showing verbatim text next to code output (for package documentation and user learning purposes)
\NewTCBListing{verbbox}{ !O{} }{
    listing engine=minted,
    minted language=latex,
    boxrule=1pt,sidebyside,skin=bicolor,
    colback=gray!10,colbacklower=white,valign=center,
    top=2pt,bottom=2pt,left=2pt,right=2pt,
    #1
} % Last argument allows more tcolorbox options to be added

\setlength{\parindent}{0.2in}
\setlength{\parskip}{0pt}
\setlength{\columnseprule}{0pt}

\makeatletter
% Redefining the title block
\renewcommand\maketitle{
    \null\vspace{4mm}
    \begin{center}
        {\Huge\sffamily\bfseries\selectfont\@title}\\
            \vspace{4mm}
        {\Large\sffamily\selectfont\@author}\\
            \vspace{4mm}
        {\large\sffamily\selectfont\@date}
    \end{center}
    \vspace{6mm}
}
% Adapted from https://tex.stackexchange.com/questions/483953/how-to-add-new-macros-like-author-without-editing-latex-ltx?noredirect=1&lq=1
\makeatother

\title{Tarea \#2 Física numérica}
\author{Oscar Andrés Valencia Magaña}
\date{\today}
% Created April 6, 2023

\begin{document}
\maketitle
% Tarea 2 Bis
% Temas: Cancelación sustractiva & Funciones de Bessel esféricas

% Que son y por qué las vamos a trabajar:
\section*{Introducción}
A lo largo de esta tarea vamos a hablar de un tipo en específico de errores: los de \textbf{redondeo}, y en particular, sobre la \textbf{cancelación sustractiva} y cómo abordarla al calcular funciones especiales, tales como las \textbf{Bessel esféricas}. 

Como se ha mencionado en clase y al desarrollar tareas anteriores, la computadora nos provee de una gran velocidad al momento de realizar cálculos; sin embargo, la \emph{precisión} depende en gran medida de nosotros. El almacenamiento y representación numérica son finitos, lo que ocasiona errores de truncamiento y redondeo. Un ejemplo simple es:

\begin{align*}
	\frac{1}{3} &= 0.3333\\
	\frac{2}{3} &= 0.6667\\
	2\left(\frac{1}{3}\right)-\frac{2}{3} &= 0.6666 - 0.6667\\
	&= -0.0001 \neq 0
\end{align*}

El resultado no es exactamente cero debido a la \textbf{pérdida de dígitos significativos}. Por ello, la cancelación sustractiva es un problema importante en cálculos numéricos.

\section*{Cancelación sustractiva}
La cancelación sustractiva ocurre cuando se restan números de magnitudes similares, perdiendo precisión significativa. A continuación, se presentan ejemplos típicos y sus reescrituras estables.

\subsection*{(a) $\sqrt{x+1}-1$, para $x\approx0$}
La forma directa produce cancelación porque $\sqrt{x+1}\approx1$. Se reescribe:
\[
\sqrt{x+1}-1\left(\frac{\sqrt{x+1}+1}{\sqrt{x+1}+1}\right) = \frac{x}{\sqrt{x+1}+1}.
\]
Esta versión evita la resta directa de cantidades casi iguales.

\subsection*{(b) $\sin x - \sin y$, con $x\approx y$}
Usando identidades trigonométricas:
\[
\sin x - \sin y = 2\cos\!\left(\frac{x+y}{2}\right)\sin\!\left(\frac{x-y}{2}\right).
\]
De esta manera se evita la resta directa de dos valores cercanos.

\subsection*{(c) $x^2 - y^2$, con $x\approx y$}
Factorizando:
\[
x^2 - y^2 = (x-y)(x+y),
\]
lo que elimina la cancelación entre $x^2$ y $y^2$.

\subsection*{(d) $\frac{1-\cos x}{\sin x}$, con $x\approx0$}
Usando $1-\cos x = 2\sin^2(x/2)$:
\[
\frac{1-\cos x}{\sin x} = \tan\!\left(\frac{x}{2}\right),
\]
una expresión mucho más estable para valores pequeños de $x$.

\subsection*{(e) $\sqrt{a^2+b^2-2ab\cos\theta}$, con $a\approx b$, $\theta\ll1$}
La forma directa de la ley de cosenos sufre cancelación. Se reescribe como:
\[
c = \sqrt{(a-b)^2 + 4ab\sin^2\left(\frac{\theta}{2}\right)}.
\]
Cuando $a=b$, esta reduce a $c = 2a\sin(\theta/2)$, que es completamente estable.

\subsection*{Resultados numéricos}
El código \texttt{tarea2.py} incluye demostraciones de cada caso, comparando la forma directa y la forma estable para distintos valores.  
Se observa que la diferencia relativa puede ser de varios órdenes de magnitud menor con las expresiones estables, especialmente para $x<10^{-10}$.

\section*{2. Funciones de Bessel esféricas $j_\ell(x)$}
\subsection*{Definición}
Las funciones de Bessel esféricas se definen por:
\[
j_\ell(x) = \sqrt{\frac{\pi}{2x}}J_{\ell+1/2}(x),
\]
donde $J_{\nu}$ es la función de Bessel ordinaria. En la práctica se calculan mediante recurrencias.

\subsection*{Recurrencias}
\begin{align*}
j_{\ell+1}(x) &= \frac{2\ell+1}{x}j_\ell(x) - j_{\ell-1}(x) \quad \text{(hacia arriba)}\\
j_{\ell-1}(x) &= \frac{2\ell+1}{x}j_\ell(x) - j_{\ell+1}(x) \quad \text{(hacia abajo)}
\end{align*}

\subsection*{Método hacia arriba (Upward Recursion)}
Parte de las condiciones iniciales:
\[
j_0(x)=\frac{\sin x}{x},\quad
j_1(x)=\frac{\sin x}{x^2}-\frac{\cos x}{x},
\]
y aplica la recurrencia para obtener los términos siguientes.  
Este método es estable cuando $x$ no es demasiado pequeño y $\ell$ no es grande.

\subsection*{Método hacia abajo (Downward Recursion)}
Se inicia en un orden grande $L_\text{start}=l_{\max}+p$ con condiciones arbitrarias $y_{L+1}=0$, $y_L=1$, y se aplica la recurrencia hacia abajo:
\[
y_{\ell-1} = \frac{2\ell+1}{x}y_\ell - y_{\ell+1}.
\]
Luego se normaliza usando $j_0(x)$ exacto:
\[
j_\ell(x) = \frac{j_0(x)}{y_0}y_\ell.
\]
Este método es numéricamente más estable y permite alcanzar errores relativos menores a $10^{-10}$ con un número suficiente de pasos de “relleno” ($\text{pad}$).

\subsection*{Algoritmo de Miller}
El código también implementa una versión del método de Miller, que es una forma optimizada de la recurrencia hacia abajo, y que proporciona una excelente estabilidad numérica.

\section*{3. Resultados numéricos}
El programa calcula y compara los valores de $j_\ell(x)$ para $\ell=0\ldots24$ y $x=0.1,\,1,\,10$, usando los tres métodos: \texttt{up}, \texttt{down} y \texttt{miller}.  
Las salidas incluyen columnas de diferencias absolutas y relativas, y la métrica del enunciado:
\[
\frac{|j_\ell^{(up)}-j_\ell^{(down)}|}{|j_\ell^{(up)}|+|j_\ell^{(down)}|}.
\]

Los resultados muestran:
\begin{itemize}
    \item Para $x$ grande ($x=10$), ambos métodos concuerdan hasta $\sim10^{-14}$.
    \item Para $x$ pequeño ($x=0.1$), el método hacia arriba se vuelve inestable para $\ell>15$.
    \item El método hacia abajo (o Miller) mantiene precisión mejor que $10^{-10}$ en todo el rango.
\end{itemize}
%% Cancelación sustractiva:

\section{Codificación}
\begin{python}[Tarea 2: implementaciones en python](style=one-dark){colback=gray!40!black,colframe=blue}
"""
tarea2.py
Solución de la Tarea #2 (cancelación sustractiva y funciones de Bessel esféricas).
Contiene:
 - demostraciones numéricas de reescrituras que evitan cancelación
 - cálculo de j_l(x) por recurrencia hacia arriba (up)
 - cálculo de j_l(x) por recurrencia hacia abajo (down) con normalización
 - comparación y ajuste para alcanzar error relativo <= 1e-10 (cuando sea posible)
"""

from __future__ import annotations
import math
import numpy as np

# ----------------------------
# Utilidades
# ----------------------------

def isclose_rel(a, b, tol=1e-12):
    # Verifica si dos números son "cercanos" en términos relativos.
    # Calcula la diferencia relativa entre `a` y `b` y la compara con un umbral `tol`.
    a = float(a); b = float(b)
    denom = max(abs(a), abs(b), 1e-300)  # Evita división por cero usando un denominador mínimo.
    return abs(a-b)/denom <= tol

# ----------------------------
# 1) Cancelación sustractiva: reescrituras y comparaciones
# ----------------------------

def sqrt_minus_one_direct(x):
    # Implementación directa de sqrt(x+1) - 1, que puede sufrir cancelación sustractiva para valores pequeños de x.
    return math.sqrt(x+1.0) - 1.0

def sqrt_minus_one_stable(x):
    # Implementación estable de sqrt(x+1) - 1, reescrita para evitar cancelación sustractiva.
    # Utiliza la identidad: sqrt(x+1) - 1 = x / (sqrt(x+1) + 1).
    return x / (math.sqrt(x+1.0) + 1.0)

def sin_minus_sin_direct(x,y):
    # Implementación directa de sin(x) - sin(y), que puede sufrir cancelación para x \approx y.
    return math.sin(x) - math.sin(y)

def sin_minus_sin_stable(x,y):
    # Implementación estable de sin(x) - sin(y), utilizando identidades trigonométricas.
    # Usa la identidad: sin(x) - sin(y) = 2*cos((x+y)/2)*sin((x-y)/2).
    return 2.0*math.cos(0.5*(x+y))*math.sin(0.5*(x-y))

def sqdiff_direct(x,y):
    # Implementación directa de x^2 - y^2, que puede sufrir cancelación para x \approx y.
    return x*x - y*y

def sqdiff_stable(x,y):
    # Implementación estable de x^2 - y^2, utilizando factorización algebraica.
    # Usa la identidad: x^2 - y^2 = (x-y)*(x+y).
    return (x-y)*(x+y)

def one_minus_cos_over_sin_direct(x):
    # Implementación directa de (1 - cos(x)) / sin(x), que puede ser inestable para x \approx 0.
    # Maneja el caso especial x=0 para evitar división por cero.
    if x == 0.0:
        return 0.0
    return (1.0 - math.cos(x))/math.sin(x)

def one_minus_cos_over_sin_stable(x):
    # Implementación estable de (1 - cos(x)) / sin(x), utilizando identidades trigonométricas.
    # Usa la identidad: (1 - cos(x)) / sin(x) = tan(x/2).
    if x == 0.0:
        return 0.0
    return math.tan(0.5*x)

def law_of_cos_direct(a,b,theta):
    # Implementación directa de la ley de cosenos para calcular la longitud del tercer lado de un triángulo.
    return math.sqrt(a*a + b*b - 2.0*a*b*math.cos(theta))

def law_of_cos_stable(a,b,theta):
    # Implementación estable de la ley de cosenos, reescrita para evitar cancelación numérica.
    # Usa la identidad: sqrt(a^2 + b^2 - 2ab*cos(theta)) = sqrt((a-b)^2 + 4ab*sin^2(theta/2)).
    return math.sqrt((a-b)**2 + 4.0*a*b*(math.sin(0.5*theta)**2))


def demo_cancellation_examples():
    # Demostración de ejemplos de cancelación sustractiva y sus soluciones estables.
    print("=== Cancelación sustractiva: comparaciones numéricas ===")

    print("(a) sqrt(x+1)-1 para valores pequeños de x")
    print("x\t\tDirecto\t\t\tEstable\t\t\tRel. Diff")
    for x in [1e-8, 1e-12, 1e-16, 1e-20, 1e-30]:
        d = sqrt_minus_one_direct(x)  # Implementación directa
        s = sqrt_minus_one_stable(x)  # Implementación estable
        rel_diff = abs(d-s)/max(abs(s),1e-300)
        print(f"{x: .1e}\t{d:.17e}\t{s:.17e}\t{rel_diff:.2e}")
    print()

    print("(b) sin(x) - sin(y) para x y")
    print("x\ty\t\tDirecto\t\t\tEstable\t\t\tRel. Diff")
    x = 1.23456789
    for eps in [1e-6, 1e-8, 1e-12, 1e-16, 1e-20]:
        y = x + eps
        d = sin_minus_sin_direct(x,y)  # Implementación directa
        s = sin_minus_sin_stable(x,y)  # Implementación estable
        rel_diff = abs(d-s)/max(abs(s),1e-300)
        print(f"{x:.8f}\t{y:.8f}\t{d:.17e}\t{s:.17e}\t{rel_diff:.2e}")
    print()

    print("(c) x^2 - y^2 para x y")
    print("x\ty\t\tDirecto\t\t\tEstable\t\t\tRel. Diff")
    for x, y in [(1.0000001, 1.0), (1.0000000001, 1.0), (1.0000000000001, 1.0), (1.0000000000000001, 1.0)]:
        d = sqdiff_direct(x,y)  # Implementación directa
        s = sqdiff_stable(x,y)  # Implementación estable
        rel_diff = abs(d-s)/max(abs(s),1e-300)
        print(f"{x:.16f}\t{y:.16f}\t{d:.17e}\t{s:.17e}\t{rel_diff:.2e}")
    print()

    print("(d) (1-cos(x))/sin(x) para x pequeño")
    print("x\t\tDirecto\t\t\tEstable\t\t\tRel. Diff")
    for x in [1e-6, 1e-8, 1e-12, 1e-16, 1e-20]:
        d = one_minus_cos_over_sin_direct(x)  # Implementación directa
        s = one_minus_cos_over_sin_stable(x)  # Implementación estable
        rel_diff = abs(d-s)/max(abs(s),1e-300)
        print(f"{x: .1e}\t{d:.17e}\t{s:.17e}\t{rel_diff:.2e}")
    print()

    print("(e) Ley de cosenos para ángulos pequeños")
    print("a\tb\ttheta\t\tDirecto\t\t\tEstable\t\t\tRel. Diff")
    a = 1.0
    b = 0.999999999999
    for theta in [1e-3, 1e-6, 1e-8, 1e-12, 1e-16]:
        d = law_of_cos_direct(a,b,theta)  # Implementación directa
        s = law_of_cos_stable(a,b,theta)  # Implementación estable
        rel_diff = abs(d-s)/max(abs(s),1e-300)
        print(f"{a:.1f}\t{b:.12f}\t{theta:.1e}\t{d:.17e}\t{s:.17e}\t{rel_diff:.2e}")
    print("=== fin demo cancelación ===\n")

# ----------------------------
# 2) Bessel esférica j_l(x) por up y por down
# ----------------------------
# j0, j1 closed forms
def j0(x):
    # Cálculo cerrado de la función de Bessel esférica de orden 0.
    if x == 0.0:
        return 1.0
    return math.sin(x)/x

def j1(x):
    # Cálculo cerrado de la función de Bessel esférica de orden 1.
    if x == 0.0:
        return 0.0
    return math.sin(x)/(x*x) - math.cos(x)/x

def j_l_up(x, lmax):
    """Calcula j_l para l=0..lmax usando la recurrencia hacia arriba (usando j0,j1 exactas)."""
    # Inicializa un arreglo para almacenar los valores de j_l.
    js = np.zeros(lmax+1, dtype=float)
    js[0] = j0(x)  # j_0(x) calculado directamente.
    if lmax == 0:
        return js
    js[1] = j1(x)  # j_1(x) calculado directamente.
    # Aplica la recurrencia hacia arriba para calcular j_l(x) para l >= 2.
    for l in range(1, lmax):
        js[l+1] = ((2*l+1)/x)*js[l] - js[l-1]
    return js

def j_l_down(x, lmax, pad=60):
    """
    Calcula j_l para l=0..lmax usando recurrencia hacia abajo con normalización.
    pad: número adicional de órdenes para arrancar arriba (se usa Lstart = lmax + pad).
    Método:
     - Inicializamos y_{L+1}=0, y_L=1 y aplicamos recurrencia hacia abajo
     - Normalizamos para que y_0 == j0(x)
    """
    # Maneja el caso especial x == 0: sólo j0(0)=1, j_l(0)=0 para l>0.
    if x == 0.0:
        js = np.zeros(lmax+1, dtype=float)
        js[0] = 1.0
        return js

    # Define el orden inicial para la recurrencia hacia abajo.
    Lstart = lmax + pad
    y = np.zeros(Lstart+2, dtype=float)  # Arreglo para almacenar valores intermedios.
    y[Lstart+1] = 0.0  # Condición inicial: y_{L+1} = 0.
    y[Lstart] = 1.0  # Condición inicial: y_L = 1.
    # Aplica la recurrencia hacia abajo para calcular y_{ell-1}.
    for ell in range(Lstart, 0, -1):
        y[ell-1] = ((2*ell+1)/x) * y[ell] - y[ell+1]
    # Normaliza los valores para que y_0 coincida con j0(x).
    factor = j0(x) / y[0]
    js = factor * y[:lmax+1]
    return js

def j_l_miller(x, lmax, pad=60):
    """
    Calcula j_l para l=0..lmax usando el algoritmo de Miller con normalización.
    Este método es una variante optimizada de la recurrencia hacia abajo.

    Parámetros:
    - x: valor en el que se evalúan las funciones de Bessel.
    - lmax: orden máximo de las funciones de Bessel a calcular.
    - pad: número adicional de órdenes para arrancar arriba (Lstart = lmax + pad).

    Retorna:
    - js: arreglo con los valores de j_l(x) para l=0..lmax.
    """
    # Maneja el caso especial x == 0: sólo j0(0)=1, j_l(0)=0 para l>0.
    if x == 0.0:
        js = np.zeros(lmax+1, dtype=float)
        js[0] = 1.0
        return js

    # Define el orden inicial para la recurrencia hacia abajo.
    Lstart = lmax + pad
    y = np.zeros(Lstart+2, dtype=float)  # Arreglo para almacenar valores intermedios.
    y[Lstart+1] = 0.0  # Condición inicial: y_{L+1} = 0.
    y[Lstart] = 1.0  # Condición inicial: y_L = 1.

    # Aplica la recurrencia hacia abajo para calcular y_{ell-1}.
    for ell in range(Lstart, 0, -1):
        y[ell-1] = ((2*ell+1)/x) * y[ell] - y[ell+1]

    # Normaliza los valores para que y_0 coincida con j0(x).
    factor = j0(x) / y[0]
    js = factor * y[:lmax+1]
    return js

def adjust_pad_for_precision(x, lmax, target_rel=1e-10, pad_start=10, pad_max=2000):
    """
    Ajusta el valor de 'pad' para cumplir con un error relativo objetivo entre
    j_l_down(pad) y j_l_down(pad*2).
    """
    pad = pad_start
    prev = j_l_down(x, lmax, pad=pad)
    while pad <= pad_max:
        pad2 = pad*2
        curr = j_l_down(x, lmax, pad=pad2)
        # Calcula la diferencia relativa máxima entre prev y curr.
        rels = np.abs(prev - curr) / np.maximum(np.maximum(np.abs(prev), np.abs(curr)), 1e-300)
        maxrel = np.max(rels)
        if maxrel <= target_rel:
            return pad2, curr
        pad = pad2
        prev = curr
    # Si no se cumple el criterio, retorna el último valor calculado.
    return pad, curr

# ----------------------------
# Routines de comparación y salida
# ----------------------------
def compare_methods_for_x(x, lmax=24, target_rel=1e-10):
    # Compara los métodos de cálculo hacia arriba y hacia abajo para un valor dado de x.
    print(f"---- Comparación para x = {x} ----")
    up = j_l_up(x, lmax)  # Calcula j_l usando recurrencia hacia arriba.
    # Ajusta el padding para la recurrencia hacia abajo.
    pad, down = adjust_pad_for_precision(x, lmax, target_rel=target_rel, pad_start=20, pad_max=20480)
    print(f"Usando pad = {pad} para down (criterio target_rel={target_rel})")
    # Imprime una tabla con los resultados.
    header = ("l", "j_up", "j_down", "abs_diff", "rel_diff", "metric_enunciado")
    print("{:>3s} {:>17s} {:>17s} {:>12s} {:>12s} {:>12s}".format(*header))
    for l in range(lmax+1):
        ju = up[l]
        jd = down[l]
        absdiff = abs(ju - jd)
        denom = (abs(ju) + abs(jd))
        metric = absdiff/denom if denom != 0 else 0.0
        rel = absdiff / max(abs(jd), 1e-300)
        print(f"{l:3d} {ju:17.12e} {jd:17.12e} {absdiff:12.4e} {rel:12.4e} {metric:12.4e}")
    print("---- fin comparacion ----\n")
    return up, down

def compare_methods_with_miller(x, lmax=24, target_rel=1e-10):
    """
    Compara los métodos de cálculo hacia arriba, hacia abajo y Miller para un valor dado de x.

    Parámetros:
    - x: valor en el que se evalúan las funciones de Bessel.
    - lmax: orden máximo de las funciones de Bessel a calcular.
    - target_rel: error relativo objetivo para ajustar el padding en el método hacia abajo.

    Retorna:
    - up: valores calculados con recurrencia hacia arriba.
    - down: valores calculados con recurrencia hacia abajo.
    - miller: valores calculados con el algoritmo de Miller.
    """
    print(f"---- Comparación para x = {x} ----")
    up = j_l_up(x, lmax)  # Calcula j_l usando recurrencia hacia arriba.
    # Ajusta el padding para la recurrencia hacia abajo.
    pad, down = adjust_pad_for_precision(x, lmax, target_rel=target_rel, pad_start=20, pad_max=20480)
    print(f"Usando pad = {pad} para down (criterio target_rel={target_rel})")
    miller = j_l_miller(x, lmax, pad=pad)  # Calcula j_l usando el algoritmo de Miller.

    # Imprime una tabla con los resultados.
    header = (
        "l", "j_up", "j_down", "j_miller", 
        "|up-down|", "|up-miller|", "|down-miller|"
    )
    print("{:<3} {:>15} {:>15} {:>15} {:>15} {:>15} {:>15}".format(*header))
    print("-" * 105)
    for l in range(lmax+1):
        ju = up[l]
        jd = down[l]
        jm = miller[l]
        abs_diff_up_down = abs(ju - jd)
        abs_diff_up_miller = abs(ju - jm)
        abs_diff_down_miller = abs(jd - jm)
        print(f"{l:<3} {ju:15.8e} {jd:15.8e} {jm:15.8e} {abs_diff_up_down:15.8e} {abs_diff_up_miller:15.8e} {abs_diff_down_miller:15.8e}")
    print("-" * 105)
    print("---- fin comparacion ----\n")
    return up, down, miller

def run_all():
    demo_cancellation_examples()  # Ejecuta las demostraciones de cancelación.
    # Ejecuta todas las demostraciones y comparaciones.
    xs = [0.1, 1.0, 10.0]  # Valores de x para comparar.
    lmax = 24  # Máximo orden de j_l.
    for x in xs:
        compare_methods_with_miller(x, lmax=lmax, target_rel=1e-10)

if __name__ == "__main__":
    run_all()
\end{python}
\begin{itemize}
    \item La cancelación sustractiva es una fuente importante de error de redondeo; reescribir las expresiones es la forma más efectiva de evitarla.
    \item En el cálculo de funciones especiales, la dirección de la recurrencia determina la estabilidad numérica.
    \item El método hacia abajo (Miller) proporciona resultados más precisos y robustos que la recurrencia hacia arriba.
    \item Las pruebas numéricas corroboran que con una normalización adecuada y un \texttt{pad} suficiente se logra un error relativo menor a $10^{-10}$.
\end{itemize}
\end{document}