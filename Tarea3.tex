\documentclass[10pt]{extarticle}

\usepackage[spanish]{babel}
\usepackage[T1]{fontenc}
\usepackage{lmodern,mathrsfs}
\usepackage{amssymb}
\usepackage{xparse}
\usepackage[inline,shortlabels]{enumitem}
\setlist{topsep=2pt,itemsep=2pt,parsep=0pt,partopsep=0pt}
\usepackage[dvipsnames]{xcolor}
\usepackage[utf8]{inputenc}
\usepackage[a4paper,top=0.5in,bottom=0.2in,left=0.5in,right=0.5in,footskip=0.3in,includefoot]{geometry}
\usepackage[most]{tcolorbox}
\tcbuselibrary{minted} % tcolorbox minted library, required to use the "minted" tcb listing engine (this library is not loaded by the option [most])
\usepackage{minted} % Allows input of raw code, such as Python code
\usepackage[colorlinks]{hyperref} % ALWAYS load this package LAST
\usepackage{listings}
\lstset{
    basicstyle=\ttfamily\footnotesize,
    keywordstyle=\color{blue},
    commentstyle=\color{gray},
    stringstyle=\color{green!40!black},
    showstringspaces=false,
    numbers=left,
    numberstyle=\tiny,
    frame=single,
    breaklines=true
}

% Custom tcolorbox style for Python code (not the code or the box it appears in, just the options for the box)
\tcbset{
    pythoncodebox/.style={
        enhanced jigsaw,breakable,
        colback=gray!10,colframe=gray!20!black,
        boxrule=1pt,top=2pt,bottom=2pt,left=2pt,right=2pt,
        sharp corners,before skip=10pt,after skip=10pt,
        attach boxed title to top left,
        boxed title style={empty,
            top=0pt,bottom=0pt,left=2pt,right=2pt,
            interior code={\fill[fill=tcbcolframe] (frame.south west)
                --([yshift=-4pt]frame.north west)
                to[out=90,in=180] ([xshift=4pt]frame.north west)
                --([xshift=-8pt]frame.north east)
                to[out=0,in=180] ([xshift=16pt]frame.south east)
                --cycle;
            }
        },
        title={#1}, % Argument of pythoncodebox specifies the title
        fonttitle=\sffamily\bfseries
    },
    pythoncodebox/.default={}, % Default is No title
    %%% Starred version has no frame %%%
    pythoncodebox*/.style={
        enhanced jigsaw,breakable,
        colback=gray!10,coltitle=gray!20!black,colbacktitle=tcbcolback,
        frame hidden,
        top=2pt,bottom=2pt,left=2pt,right=2pt,
        sharp corners,before skip=10pt,after skip=10pt,
        attach boxed title to top text left={yshift=-1mm},
        boxed title style={empty,
            top=0pt,bottom=0pt,left=2pt,right=2pt,
            interior code={\fill[fill=tcbcolback] (interior.south west)
                --([yshift=-4pt]interior.north west)
                to[out=90,in=180] ([xshift=4pt]interior.north west)
                --([xshift=-8pt]interior.north east)
                to[out=0,in=180] ([xshift=16pt]interior.south east)
                --cycle;
            }
        },
        title={#1}, % Argument of pythoncodebox specifies the title
        fonttitle=\sffamily\bfseries
    },
    pythoncodebox*/.default={}, % Default is No title
}

% Custom tcolorbox for Python code (not the code itself, just the box it appears in)
\newtcolorbox{pythonbox}[1][]{pythoncodebox=#1}
\newtcolorbox{pythonbox*}[1][]{pythoncodebox*=#1} % Starred version has no frame

% Custom minted environment for Python code, NOT using tcolorbox
\newminted{python}{autogobble,breaklines,mathescape}

% Custom tcblisting environment for Python code, using the "minted" tcb listing engine
% Adapted from https://tex.stackexchange.com/a/402096
\NewTCBListing{python}{ !O{} !D(){} !G{} }{
    listing engine=minted,
    listing only,
    pythoncodebox={#1}, % First argument specifies the title (if any)
    minted language=python,
    minted options/.expanded={
        autogobble,breaklines,mathescape,
        #2 % Second argument, delimited by (), denotes options for the minted environment
    },
    #3 % Third argument, delimited by {}, denotes options for the tcolorbox
}

%%% Starred version has no frame %%%
\NewTCBListing{python*}{ !O{} !D(){} !G{} }{
    listing engine=minted,
    listing only,
    pythoncodebox*={#1}, % First argument specifies the title (if any)
    minted language=python,
    minted options/.expanded={
        autogobble,breaklines,mathescape,
        #2 % Second argument, delimited by (), denotes options for the minted environment
    },
    #3 % Third argument, delimited by {}, denotes options for the tcolorbox
}

% verbbox environment, for showing verbatim text next to code output (for package documentation and user learning purposes)
\NewTCBListing{verbbox}{ !O{} }{
    listing engine=minted,
    minted language=latex,
    boxrule=1pt,sidebyside,skin=bicolor,
    colback=gray!10,colbacklower=white,valign=center,
    top=2pt,bottom=2pt,left=2pt,right=2pt,
    #1
} % Last argument allows more tcolorbox options to be added

\setlength{\parindent}{0.2in}
\setlength{\parskip}{0pt}
\setlength{\columnseprule}{0pt}

\makeatletter
% Redefining the title block
\renewcommand\maketitle{
    \null\vspace{4mm}
    \begin{center}
        {\Huge\sffamily\bfseries\selectfont\@title}\\
            \vspace{4mm}
        {\Large\sffamily\selectfont\@author}\\
            \vspace{4mm}
        {\large\sffamily\selectfont\@date}
    \end{center}
    \vspace{6mm}
}
% Adapted from https://tex.stackexchange.com/questions/483953/how-to-add-new-macros-like-author-without-editing-latex-ltx?noredirect=1&lq=1
\makeatother

\title{Tarea \#3 Física numérica}
\author{Oscar Andrés Valencia Magaña}
\date{\today}
% Created April 6, 2023

\begin{document}
\maketitle
\section{Introducción}

En esta tarea se aborda el estudio del proceso de \textbf{difusión térmica en una barra}, con el propósito de analizar su comportamiento tanto desde un enfoque \textbf{analítico} como \textbf{numérico}. El objetivo principal es comprender la evolución temporal de la distribución de temperatura bajo diferentes condiciones de frontera y parámetros del sistema.

De manera específica, se pretende:
\begin{itemize}
\item Derivar y presentar la solución analítica del problema cuando ésta sea posible.
\item Diseñar e implementar esquemas numéricos adecuados (métodos explícitos, implícitos o mixtos) detallando el procedimiento paso a paso.
\item Realizar una comparación cuantitativa entre los resultados numéricos y las soluciones analíticas disponibles, evaluando la precisión y estabilidad de los métodos empleados.
\item Documentar el desarrollo computacional y anexar el código correspondiente como \textbf{apéndice}, garantizando la reproducibilidad de los resultados obtenidos.
\end{itemize}
\section{Planteamiento del problema y ecuación propuesta}

Consideremos una barra homogénea de longitud \(L\), aislada térmicamente a lo largo de su superficie lateral, cuyos extremos se mantienen a temperatura nula. Sea \(T(x,t)\) la temperatura en la posición \(x \in [0, L]\) y en el instante \(t \ge 0\). El fenómeno de difusión térmica en una dimensión se describe mediante la \textbf{ecuación del calor}:

\[
\frac{\partial T}{\partial t} = \alpha \frac{\partial^2 T}{\partial x^2},
\]

donde \(\alpha\) representa la \emph{difusividad térmica} del material, dada por la relación:
\[
\alpha = \frac{k}{\rho c_p},
\]
siendo \(k\) la conductividad térmica, \(\rho\) la densidad y \(c_p\) el calor específico a presión constante.

Las condiciones inicial y de frontera se definen como:
\[
T(x,0) = T_0 \quad (\text{condición inicial, temperatura uniforme}),
\]
\[
T(0,t) = 0, \quad T(L,t) = 0 \quad \forall t \ge 0.
\]

\subsection{Solución analítica por separación de variables}

Buscamos una solución de la forma separable:
\[
T(x,t) = X(x)G(t).
\]
Sustituyendo en la ecuación del calor, se obtiene:
\[
X(x)G'(t) = \alpha X''(x)G(t),
\]
y tras dividir por \(\alpha X(x)G(t)\), resulta:
\[
\frac{1}{\alpha}\frac{G'(t)}{G(t)} = \frac{X''(x)}{X(x)} = -\lambda,
\]
donde \(\lambda\) es la \emph{constante de separación}.

Las condiciones de frontera \(X(0)=X(L)=0\) implican un problema de valores propios que conduce a:
\[
\lambda_n = \left(\frac{n\pi}{L}\right)^2, \quad n \in \mathbb{N},
\]
con funciones propias asociadas:
\[
X_n(x) = \sin\!\left(\frac{n\pi x}{L}\right).
\]
La solución temporal correspondiente es:
\[
G_n(t) = e^{-\alpha (n\pi/L)^2 t}.
\]
Por principio de superposición, la solución general se expresa como:
\[
T(x,t) = \sum_{n=1}^{\infty} b_n \sin\!\left(\frac{n\pi x}{L}\right) e^{-\alpha (n\pi/L)^2 t}.
\]

Los coeficientes \(b_n\) se determinan a partir de la condición inicial \(T(x,0) = T_0\):
\[
b_n = \frac{2}{L} \int_0^L T_0 \sin\!\left(\frac{n\pi x}{L}\right) dx = 
\frac{4T_0}{n\pi} \quad \text{para } n \text{ impar}, \quad b_n = 0 \text{ si } n \text{ par.}
\]

Por tanto, la solución analítica final, considerando únicamente los términos impares (\(n = 2k + 1\)), es:
\[
\boxed{
T(x,t) = \sum_{k=0}^{\infty} \frac{4T_0}{(2k+1)\pi} 
\sin\!\left(\frac{(2k+1)\pi x}{L}\right) 
e^{-\alpha \left(\frac{(2k+1)\pi}{L}\right)^2 t}.
}
\]

Esta solución describe la evolución temporal de la temperatura en la barra, mostrando cómo los modos armónicos de oscilación térmica se atenúan exponencialmente en el tiempo. El término fundamental (\(k=0\)) domina el comportamiento a largo plazo, representando el modo más lento de disipación térmica.
\subsection{Discretización y esquema numérico FTCS (explícito)}

Para la resolución numérica se emplea un mallado uniforme en el dominio espacial y temporal. Definimos
\[
x_i = i\,\Delta x,\qquad i=0,\ldots,N,
\qquad
t^n = n\,\Delta t,\qquad n=0,1,2,\ldots
\]
con \(\Delta x = L/N\). Denotamos por \(T_i^n\) la aproximación numérica de \(T(x_i,t^n)\).

Aproximaciones por diferencias finitas centradas en el espacio y hacia adelante en el tiempo:
\[
\frac{\partial T}{\partial t}\Big|_{(x_i,t^n)} \approx \frac{T_i^{n+1}-T_i^n}{\Delta t},
\qquad
\frac{\partial^2 T}{\partial x^2}\Big|_{(x_i,t^n)} \approx \frac{T_{i+1}^n - 2T_i^n + T_{i-1}^n}{(\Delta x)^2}.
\]
Sustituyendo en la ecuación del calor obtenemos el esquema explícito FTCS (Forward Time — Centered Space):
\[
\frac{T_i^{n+1}-T_i^n}{\Delta t} = \alpha\,\frac{T_{i+1}^n - 2T_i^n + T_{i-1}^n}{(\Delta x)^2}.
\]
Definiendo el número adimensional
\[
r \equiv \frac{\alpha\Delta t}{(\Delta x)^2},
\]
la fórmula de actualización toma la forma compacta
\[
\boxed{\,T_i^{n+1} = T_i^n + r\big(T_{i+1}^n - 2T_i^n + T_{i-1}^n\big)\,}
\qquad\text{para } i=1,\dots,N-1.
\]

\subsubsection*{Orden de consistencia}
El esquema FTCS es de \(\mathcal{O}(\Delta t)\) en tiempo (diferencia hacia adelante) y \(\mathcal{O}(\Delta x^2)\) en espacio (segunda diferencia centrada). La precisión global es, por tanto, dominada por el término temporal si \(\Delta t\) no es suficientemente pequeño.

\subsubsection{Condición de estabilidad (análisis de von Neumann)}
Aplicando el análisis de Fourier (von Neumann) al esquema anterior se obtiene la condición de estabilidad:
\[
r \le \frac{1}{2} \qquad\Longleftrightarrow\qquad
\Delta t \le \frac{(\Delta x)^2}{2\alpha}.
\]
Si \(r>1/2\) el esquema explota numéricamente (crecimientos exponenciales no físicos o oscilaciones no amortiguadas). Esta restricción es una manifestación de la condición CFL (Courant--Friedrichs--Lewy) para el esquema explícito aplicado a la ecuación de difusión.

\subsection{Implementación: algoritmo paso a paso}

A continuación se expone un pseudocódigo y recomendaciones prácticas para implementar FTCS de forma robusta:

\begin{enumerate}
  \item \textbf{Parámetros físicos y discretización.} Fijar \(L, T_0, \alpha\) y el número de subdivisiones \(N\). Calcular \(\Delta x = L/N\).
  \item \textbf{Elección de \(\Delta t\).} Seleccionar \(\Delta t\) de modo que \(r=\alpha\Delta t/(\Delta x)^2 \le 1/2\). Como regla práctica inicial, usar \(r\approx 0.4\) para margen de seguridad.
  \item \textbf{Inicialización.} 
    \[
    T_i^0 = T_0\quad (i=1,\dots,N-1),\qquad T_0^n = 0,\; T_N^n = 0\quad \forall n.
    \]
    Asegúrate de imponer las condiciones de Dirichlet en cada paso temporal.
  \item \textbf{Bucle temporal.} Para \(n=0,1,\dots,n_{\max}-1\):
    \begin{enumerate}
      \item Para cada nodo interior \(i=1,\dots,N-1\) calcular
      \[
      T_i^{n+1} = T_i^n + r\big(T_{i+1}^n - 2T_i^n + T_{i-1}^n\big).
      \]
      \item Imponer \(T_0^{n+1}=0,\; T_N^{n+1}=0\).
      \item (Opcional) Evaluar criterio de parada o guardar perfil para postprocesado.
    \end{enumerate}
  \item \textbf{Cómputo de error.} Para comparar con la solución analítica truncada \(T_{\mathrm{an}}(x,t)\), calcular la norma RMS:
  \[
  E_2(t^n)=\sqrt{\frac{1}{N-1}\sum_{i=1}^{N-1}\big(T_i^n - T_{\mathrm{an}}(x_i,t^n)\big)^2 }.
  \]
  Además es útil calcular norma máximo (error infinito):
  \[
  E_\infty(t^n)=\max_{1\le i\le N-1} |T_i^n - T_{\mathrm{an}}(x_i,t^n)|.
  \]
\end{enumerate}

\subsubsection*{Recomendaciones prácticas}
\begin{itemize}
  \item Para evaluar la solución analítica numéricamente, trunca la serie de Fourier a un número suficientemente grande de términos \(M\) (por ejemplo \(M\sim 100\)–\(500\)) y comprueba la convergencia relativa del truncamiento.
  \item Al guardar soluciones en archivos, incluye metadatos (valores de \(\Delta x,\Delta t,\alpha, N\)) para reproducibilidad.
  \item Verifica conservación energética aproximada (o decaimiento esperado) para detectar errores de implementación.
  \item Para valores de \(\alpha\) pequeños o mallas muy finas, la restricción de estabilidad puede volver la simulación muy lenta; en esos casos considera esquemas implícitos.
\end{itemize}

\subsection{Nota comparativa: esquemas implícitos y Crank--Nicolson}

El esquema explícito FTCS es simple y eficiente por paso (solo operaciones puntuales), pero su estabilidad condicionada puede exigir \(\Delta t\) muy pequeño. Como alternativa:

\begin{itemize}
  \item \textbf{Esquema implícito (Backward Euler)}: estable para cualquier \(r>0\) (incondicionalmente estable), pero requiere resolver un sistema lineal tridiagonal en cada paso (método de Thomas).
  \item \textbf{Crank--Nicolson}: esquema centrado en el tiempo (promedio de explicito e implícito), es de segundo orden en tiempo y espacio y es incondicionalmente estable; igualmente implica resolver un sistema lineal por paso.
\end{itemize}

La elección entre explícito e implícito depende del problema: si se requieren pasos de tiempo grandes o \(\alpha\) es pequeño, conviene emplear un esquema implícito o Crank--Nicolson; si la malla temporal requerida por estabilidad es aceptable, FTCS ofrece implementación directa y bajo coste por paso.

\subsection{Observaciones sobre errores numéricos}

\begin{itemize}
  \item \textbf{Error de consistencia (truncamiento)}: depende de \(\Delta t\) y \(\Delta x^2\).
  \item \textbf{Error de estabilidad/propagación}: controlado por la condición de von Neumann.
  \item \textbf{Difusión numérica}: el esquema puede introducir disipación artificial; comparar con la solución analítica permite cuantificarla.
\end{itemize}
\subsection{Efecto del material (difusividad térmica)}

La velocidad de propagación del calor depende directamente de la difusividad térmica \(\alpha\) del material, definida como \(\alpha = k/(\rho c_p)\), donde \(k\) es la conductividad térmica, \(\rho\) la densidad y \(c_p\) el calor específico. Algunos valores típicos son:

\begin{itemize}
  \item \textbf{Aluminio:} \(\alpha_{\mathrm{Al}} \approx 9\times 10^{-5}\ \mathrm{m}^2/\mathrm{s}\).
  \item \textbf{Madera:} \(\alpha_{\mathrm{madera}} \approx 1\times 10^{-6}\ \mathrm{m}^2/\mathrm{s}\) (dependiente de la densidad y humedad).
\end{itemize}

Un material con menor difusividad térmica disipa el calor más lentamente: las perturbaciones térmicas tardan más tiempo en propagarse y el gradiente de temperatura persiste durante intervalos prolongados. Por el contrario, materiales con alta difusividad, como los metales, exhiben un enfriamiento rápido y homogéneo. Numéricamente, un \(\alpha\) elevado impone una restricción más severa en el paso temporal \(\Delta t\) debido a la condición de estabilidad \(r = \alpha \Delta t / (\Delta x)^2 \le 1/2\).
\section{Nuevo problema: ecuación de Poisson con condiciones periódicas}
\subsection{Planteamiento}

Se desea resolver la ecuación de Poisson bidimensional:
\[
\frac{\partial^2 \phi}{\partial x^2} + \frac{\partial^2 \phi}{\partial y^2} = f(x,y),
\]
en el dominio rectangular periódico \([0,2\pi]\times[0,2\pi]\), sujeto a condiciones de contorno periódicas tanto en \(x\) como en \(y\):
\[
\phi(0,y) = \phi(2\pi,y), \qquad \phi(x,0) = \phi(x,2\pi).
\]
El término fuente se define como:
\[
f(x,y) = \cos(3x + 4y) - \cos(5x - 2y).
\]

Este tipo de problema es fundamental en el estudio de fenómenos estacionarios que involucran difusión, potenciales o campos escalarizados periódicos, y su resolución numérica sirve como base para validar implementaciones de operadores laplacianos discretos y técnicas de transformadas de Fourier.

\subsection{Discretización y esquema de diferencias finitas}

Para discretizar el dominio, se considera una malla uniforme de \(N\times N\) nodos, donde:
\[
x_i = i\,\Delta x,\quad y_j = j\,\Delta y,\quad \text{con}\quad \Delta x = \Delta y = \frac{2\pi}{N}, \quad i,j=0,1,\ldots,N-1.
\]

La aproximación de segunda orden mediante diferencias centrales para la ecuación de Poisson se expresa como:
\[
\frac{\phi_{i+1,j} - 2\phi_{i,j} + \phi_{i-1,j}}{(\Delta x)^2}
+ \frac{\phi_{i,j+1} - 2\phi_{i,j} + \phi_{i,j-1}}{(\Delta y)^2}
= f_{i,j}.
\]

Puesto que \(\Delta x = \Delta y\), la ecuación puede reordenarse en forma iterativa (útil para métodos como Gauss--Seidel o Jacobi) como:
\[
\boxed{
\phi_{i,j} =
\frac{1}{4}\left(
\phi_{i+1,j} + \phi_{i-1,j} + \phi_{i,j+1} + \phi_{i,j-1}
- (\Delta x)^2 f_{i,j}
\right).
}
\]

Debido a las \textbf{condiciones periódicas}, los índices deben evaluarse módulo \(N\); es decir:
\[
\phi_{N,j} = \phi_{0,j}, \qquad \phi_{i,N} = \phi_{i,0}.
\]
Esto asegura la continuidad del campo \(\phi\) en los bordes del dominio y la conservación del gradiente en los puntos de transición, característica esencial de sistemas periódicos.

\subsection{Interpretación y posibles métodos de resolución}

El sistema resultante puede resolverse mediante:
\begin{itemize}
    \item \textbf{Métodos iterativos locales}, como Jacobi o Gauss--Seidel, que actualizan la malla punto a punto hasta alcanzar la convergencia.
    \item \textbf{Métodos espectrales}, empleando transformadas rápidas de Fourier (FFT), aprovechando las condiciones periódicas para diagonalizar el operador laplaciano en el espacio de frecuencias.
\end{itemize}

Ambos enfoques permiten comparar precisión y costo computacional, siendo el método espectral particularmente eficiente para dominios periódicos regulares.
\subsection{Método iterativo: Gauss--Seidel y SOR}

Para resolver el sistema discreto resultante de la ecuación de Poisson, se pueden emplear métodos iterativos que actualizan los valores de \(\phi_{i,j}\) hasta alcanzar convergencia:

\begin{itemize}
    \item \textbf{Gauss--Seidel (GS):} en cada iteración, se actualiza \(\phi_{i,j}\) usando los valores más recientes disponibles, es decir, se realiza la actualización "in place":
    \[
    \phi_{i,j}^{\text{new}} = \frac{1}{4}\left(
    \phi_{i+1,j}^{\text{old}} + \phi_{i-1,j}^{\text{new}} + 
    \phi_{i,j+1}^{\text{old}} + \phi_{i,j-1}^{\text{new}} - (\Delta x)^2 f_{i,j}
    \right).
    \]
    Este método es simple, estable y converge lentamente para mallas grandes.

    \item \textbf{SOR (Successive Over-Relaxation):} es una extensión de Gauss--Seidel que acelera la convergencia introduciendo un factor de relajación \(\omega\):
    \[
    \phi_{i,j}^{\text{new}} = (1-\omega)\phi_{i,j}^{\text{old}} + \omega \phi_{i,j}^{\text{GS}},
    \]
    donde \(\phi_{i,j}^{\text{GS}}\) es el valor que Gauss--Seidel proporcionaría y \(1<\omega<2\) para sobre-relajación. La elección óptima de \(\omega\) depende de la malla y la geometría del dominio, y puede reducir significativamente el número de iteraciones requeridas.
\end{itemize}

\subsection{Criterio de convergencia}

Para determinar cuándo detener la iteración, se evalúa la norma del residuo máximo:
\[
\text{res} = \max_{i,j} \Bigg| 
\frac{\phi_{i+1,j}-2\phi_{i,j}+\phi_{i-1,j}}{\Delta x^2} +
\frac{\phi_{i,j+1}-2\phi_{i,j}+\phi_{i,j-1}}{\Delta y^2} - f_{i,j} 
\Bigg|.
\]

Se considera que la solución ha convergido cuando \(\text{res} < \text{tol}\), por ejemplo \(\text{tol} = 10^{-8}\). Este criterio garantiza que la ecuación discreta de Poisson se satisface con precisión numérica deseada en todos los nodos de la malla.

\subsection{Observaciones y métodos alternativos}

\begin{itemize}
    \item Para problemas con \textbf{condiciones periódicas}, la Transformada Discreta de Fourier (FFT) permite resolver la ecuación de Poisson de manera directa y eficiente, con complejidad \(O(N^2 \log N)\), evitando iteraciones y convergencia lenta.
    \item Los métodos iterativos como Gauss--Seidel son robustos, fáciles de implementar y útiles como referencia, mientras que SOR permite acelerar la convergencia al ajustar el parámetro \(\omega\) de manera adecuada.
    \item La elección del método depende del tamaño de la malla, las condiciones de contorno y los recursos computacionales disponibles.
\end{itemize}
\subsection{Método iterativo: Gauss--Seidel y SOR}

Para resolver el sistema discreto resultante de la ecuación de Poisson, se pueden emplear métodos iterativos que actualizan los valores de \(\phi_{i,j}\) hasta alcanzar convergencia:

\begin{itemize}
    \item \textbf{Gauss--Seidel (GS):} en cada iteración, se actualiza \(\phi_{i,j}\) usando los valores más recientes disponibles, es decir, se realiza la actualización "in place":
    \[
    \phi_{i,j}^{\text{new}} = \frac{1}{4}\left(
    \phi_{i+1,j}^{\text{old}} + \phi_{i-1,j}^{\text{new}} + 
    \phi_{i,j+1}^{\text{old}} + \phi_{i,j-1}^{\text{new}} - (\Delta x)^2 f_{i,j}
    \right).
    \]
    Este método es simple, estable y converge lentamente para mallas grandes.

    \item \textbf{SOR (Successive Over-Relaxation):} es una extensión de Gauss--Seidel que acelera la convergencia introduciendo un factor de relajación \(\omega\):
    \[
    \phi_{i,j}^{\text{new}} = (1-\omega)\phi_{i,j}^{\text{old}} + \omega \phi_{i,j}^{\text{GS}},
    \]
    donde \(\phi_{i,j}^{\text{GS}}\) es el valor que Gauss--Seidel proporcionaría y \(1<\omega<2\) para sobre-relajación. La elección óptima de \(\omega\) depende de la malla y la geometría del dominio, y puede reducir significativamente el número de iteraciones requeridas.
\end{itemize}

\subsection{Criterio de convergencia}

Para determinar cuándo detener la iteración, se evalúa la norma del residuo máximo:
\[
\text{res} = \max_{i,j} \Bigg| 
\frac{\phi_{i+1,j}-2\phi_{i,j}+\phi_{i-1,j}}{\Delta x^2} +
\frac{\phi_{i,j+1}-2\phi_{i,j}+\phi_{i,j-1}}{\Delta y^2} - f_{i,j} 
\Bigg|.
\]

Se considera que la solución ha convergido cuando \(\text{res} < \text{tol}\), por ejemplo \(\text{tol} = 10^{-8}\). Este criterio garantiza que la ecuación discreta de Poisson se satisface con precisión numérica deseada en todos los nodos de la malla.

\subsection{Observaciones y métodos alternativos}

\begin{itemize}
    \item Para problemas con \textbf{condiciones periódicas}, la Transformada Discreta de Fourier (FFT) permite resolver la ecuación de Poisson de manera directa y eficiente, con complejidad \(O(N^2 \log N)\), evitando iteraciones y convergencia lenta.
    \item Los métodos iterativos como Gauss--Seidel son robustos, fáciles de implementar y útiles como referencia, mientras que SOR permite acelerar la convergencia al ajustar el parámetro \(\omega\) de manera adecuada.
    \item La elección del método depende del tamaño de la malla, las condiciones de contorno y los recursos computacionales disponibles.
\end{itemize}
\section{Conclusiones}
\appendix
\section{Código Python -- Ecuación del calor (FTCS) y comparación analítica}
\begin{python}[Tarea 3: Resolución de la ec de calor](style=one-dark){colback=gray!40!black,colframe=blue}
"""
Solsución numérica (FTCS) de la ecuación del calor 1D comparada con la solución analítica
serie de Fourier. Visualizaciones optimizadas.
"""

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from matplotlib import cm

# -----------------------
# Parámetros físicos
# -----------------------
L = 1.0             # longitud (m)
T0 = 100.0          # temperatura inicial (°C)
alpha_Al = 9.7e-5   # difusividad aluminio (m^2/s) aprox
alpha_wood = 1e-6   # difusividad madera (m^2/s) aprox

# -----------------------
# Parámetros numéricos
# -----------------------
N = 200               # número de intervalos espaciales
dx = L / N
x = np.linspace(0, L, N+1)

# elegir material
alpha = alpha_Al

# tiempo de simulación (segundos)
t_final = 20000.0

# condicion de estabilidad: dt <= dx^2 / (2 alpha)
dt_stable = 0.5 * dx*dx / alpha
print(f"Paso de tiempo máximo estable dt <= {dt_stable:.3e} s")

# Usamos dt algo menor que el límite
dt = 0.9 * dt_stable

# número de pasos
nt = int(t_final / dt) + 1
print(f"Usando dt={dt:.3e}, nt={nt}")

# r = alpha dt / dx^2
r = alpha * dt / dx**2
print(f"r = {r:.6f}")

# -----------------------
# Inicialización
# -----------------------
T = np.ones(N+1) * T0
T[0] = 0.0
T[-1] = 0.0

# para superficie: guardamos cada k pasos
sample_stride = max(1, nt // 300)
T_evolution = []
t_evolution = []

# -----------------------
# Esquema explícito (FTCS)
# -----------------------
print("Ejecutando simulación FTCS...")
for n in range(nt+1):
    t = n*dt
    if n % sample_stride == 0:
        T_evolution.append(T.copy())
        t_evolution.append(t)
    # iteración FTCS (excluir puntos frontera)
    Tn = T.copy()
    T[1:-1] = Tn[1:-1] + r*(Tn[2:] - 2*Tn[1:-1] + Tn[:-2])
    T[0] = 0.0
    T[-1] = 0.0

# convertir a arrays
T_evolution = np.array(T_evolution)
t_evolution = np.array(t_evolution)

# -----------------------
# Solución analítica
# -----------------------
def analytical_T(x, t, L=1.0, T0=100.0, alpha=alpha):
    """Serie de Fourier truncada"""
    M = 500  # número de términos
    s = np.zeros_like(x)
    for k in range(M):
        n = 2*k + 1
        coef = 4*T0 / (n*np.pi)
        s += coef * np.sin(n*np.pi*x/L) * np.exp(-alpha*(n*np.pi/L)**2 * t)
    return s

# calcular solución analítica para los mismos tiempos
print("Calculando solución analítica...")
T_analytical_evolution = []
for t in t_evolution:
    T_analytical_evolution.append(analytical_T(x, t, L=L, T0=T0, alpha=alpha))
T_analytical_evolution = np.array(T_analytical_evolution)

# Calcular diferencia
T_diff = T_evolution - T_analytical_evolution

# Calcular error L2 final
error_L2_final = np.sqrt(np.mean(T_diff[-1]**2))
print(f"\nError L2 final: {error_L2_final:.6e} °C")

# -----------------------
# Preparar mallas para gráficos
# -----------------------
X, Tt = np.meshgrid(x, t_evolution)

# -----------------------
# FIGURA 1: Superficies 3D (Numérica, Analítica y Diferencia)
# -----------------------
fig = plt.figure(figsize=(18, 5))

# Subplot 1: Solución numérica
ax1 = fig.add_subplot(131, projection='3d')
surf1 = ax1.plot_surface(X, Tt, T_evolution, cmap=cm.viridis, 
                         linewidth=0, antialiased=False, alpha=0.9)
ax1.set_xlabel('x (m)', fontsize=10)
ax1.set_ylabel('t (s)', fontsize=10)
ax1.set_zlabel('T (°C)', fontsize=10)
ax1.set_title('Solución Numérica (FTCS)', fontsize=12, fontweight='bold')
ax1.view_init(elev=25, azim=45)
cbar1 = fig.colorbar(surf1, ax=ax1, shrink=0.5, aspect=10)
cbar1.set_label('T (°C)', fontsize=9)

# Subplot 2: Solución analítica
ax2 = fig.add_subplot(132, projection='3d')
surf2 = ax2.plot_surface(X, Tt, T_analytical_evolution, cmap=cm.plasma,
                         linewidth=0, antialiased=False, alpha=0.9)
ax2.set_xlabel('x (m)', fontsize=10)
ax2.set_ylabel('t (s)', fontsize=10)
ax2.set_zlabel('T (°C)', fontsize=10)
ax2.set_title('Solución Analítica (Serie Fourier)', fontsize=12, fontweight='bold')
ax2.view_init(elev=25, azim=45)
cbar2 = fig.colorbar(surf2, ax=ax2, shrink=0.5, aspect=10)
cbar2.set_label('T (°C)', fontsize=9)

# Subplot 3: Diferencia en 2D (no 3D)
ax3 = fig.add_subplot(133)
im3 = ax3.imshow(T_diff.T, extent=[0, t_final, 0, L], aspect='auto', 
                 origin='lower', cmap='RdBu_r', interpolation='bilinear')
ax3.set_xlabel('t (s)', fontsize=10)
ax3.set_ylabel('x (m)', fontsize=10)
ax3.set_title('Diferencia (Numérica - Analítica)', fontsize=12, fontweight='bold')
cbar3 = fig.colorbar(im3, ax=ax3)
cbar3.set_label('\Delta T (°C)', fontsize=9)

# Añadir información del error
error_text = f'Error L2 = {error_L2_final:.2e} °C'
ax3.text(0.02, 0.98, error_text, transform=ax3.transAxes,
         verticalalignment='top', fontsize=10, color='white',
         bbox=dict(boxstyle='round', facecolor='black', alpha=0.7))

plt.suptitle('Ecuación del Calor 1D: Comparación Numérica vs Analítica',
            fontsize=14, fontweight='bold', y=0.98)
plt.tight_layout()
plt.show()

# -----------------------
# FIGURA 2: Isotermas (Contornos)
# -----------------------
fig = plt.figure(figsize=(18, 5))

# Subplot 1: Isotermas numérica
ax1 = fig.add_subplot(131)
levels = 20
CS1 = ax1.contourf(X, Tt, T_evolution, levels=levels, cmap='viridis')
contours1 = ax1.contour(X, Tt, T_evolution, levels=10, colors='white', 
                        linewidths=0.5, alpha=0.4)
ax1.clabel(contours1, inline=True, fontsize=7, fmt='%1.1f')
ax1.set_xlabel('x (m)', fontsize=10)
ax1.set_ylabel('t (s)', fontsize=10)
ax1.set_title('Isotermas - Solución Numérica', fontsize=12, fontweight='bold')
cbar1 = fig.colorbar(CS1, ax=ax1)
cbar1.set_label('T (°C)', fontsize=9)

# Subplot 2: Isotermas analítica
ax2 = fig.add_subplot(132)
CS2 = ax2.contourf(X, Tt, T_analytical_evolution, levels=levels, cmap='plasma')
contours2 = ax2.contour(X, Tt, T_analytical_evolution, levels=10, colors='white',
                        linewidths=0.5, alpha=0.4)
ax2.clabel(contours2, inline=True, fontsize=7, fmt='%1.1f')
ax2.set_xlabel('x (m)', fontsize=10)
ax2.set_ylabel('t (s)', fontsize=10)
ax2.set_title('Isotermas - Solución Analítica', fontsize=12, fontweight='bold')
cbar2 = fig.colorbar(CS2, ax=ax2)
cbar2.set_label('T (°C)', fontsize=9)

# Subplot 3: Isotermas de la diferencia
ax3 = fig.add_subplot(133)
CS3 = ax3.contourf(X, Tt, T_diff, levels=levels, cmap='RdBu_r')
contours3 = ax3.contour(X, Tt, T_diff, levels=10, colors='black',
                        linewidths=0.5, alpha=0.3)
ax3.clabel(contours3, inline=True, fontsize=7, fmt='%1.2e')
ax3.set_xlabel('x (m)', fontsize=10)
ax3.set_ylabel('t (s)', fontsize=10)
ax3.set_title('Isotermas - Diferencia (Error)', fontsize=12, fontweight='bold')
cbar3 = fig.colorbar(CS3, ax=ax3)
cbar3.set_label('\Delta T (°C)', fontsize=9)

plt.suptitle('Isotermas de Temperatura T(x,t)',
            fontsize=14, fontweight='bold', y=0.98)
plt.tight_layout()
plt.show()

# -----------------------
# Resumen de resultados
# -----------------------
print("\n" + "="*60)
print("RESUMEN DE RESULTADOS")
print("="*60)
print(f"Parámetros:")
print(f"  - Resolución espacial: N = {N}")
print(f"  - Pasos temporales: nt = {nt}")
print(f"  - dx = {dx:.6f} m")
print(f"  - dt = {dt:.6e} s")
print(f"  - r = \alpha·dt/dx² = {r:.6f}")
print(f"\nEstabilidad:")
print(f"  - Condición: r \leq 0.5")
print(f"  - Estado: {'\checkESTABLE' if r <= 0.5 else '\notcheck INESTABLE'}")
print(f"\nError final:")
print(f"  - Error L2: {error_L2_final:.6e} °C")
print(f"  - Error máximo: {np.max(np.abs(T_diff[-1])):.6e} °C")
print("="*60)
\end{python}
\section{Código Python -- Poisson 2D (Gauss--Seidel, periodic)}
\begin{python}[Tarea 3: Ec de Poisson](style=one-dark){colback=gray!40!black,colframe=blue}
"""
poisson_2d_gauss_seidel_periodic.py

Solución numérica de la ecuación de Poisson en [0,2pí]x[0,2pi] con condiciones periódicas
usando Gauss-Seidel. Visualización de la evolución temporal.
f(x,y) = cos(3x+4y) - cos(5x-2y)
"""

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from matplotlib import cm

# -----------------------
# Parámetros del problema
# -----------------------
N = 128  # resolución de la malla (prueba con 64, 128, 256)
Lx = 2*np.pi
Ly = 2*np.pi
dx = Lx / N
dy = Ly / N

# Crear malla
x = np.linspace(0, Lx, N, endpoint=False)
y = np.linspace(0, Ly, N, endpoint=False)
X, Y = np.meshgrid(x, y, indexing='ij')

# Función fuente f(x,y)
f = np.cos(3*X + 4*Y) - np.cos(5*X - 2*Y)

# -----------------------
# Inicialización
# -----------------------
phi = np.zeros_like(f)  # condición inicial

# Parámetros de Gauss-Seidel
tol = 1e-8
max_iter = 20000
res = 1.0
it = 0

# Guardar snapshots de la evolución
snapshots = {}
snapshot_iterations = [0, 50, 200, 500, 1000, 5000]

print(f"Iniciando Gauss-Seidel con N={N}, tol={tol:.2e}")
print(f"dx={dx:.4f}, dy={dy:.4f}")
print("-" * 60)

# -----------------------
# Método de Gauss-Seidel con condiciones periódicas
# -----------------------
while res > tol and it < max_iter:
    res = 0.0
    
    # Guardar snapshot si corresponde
    if it in snapshot_iterations:
        snapshots[it] = phi.copy()
        print(f"  Snapshot guardado en iteración {it}")
    
    # Recorrer todos los puntos de la malla
    for i in range(N):
        ip = (i + 1) % N  # índice siguiente (periódico)
        im = (i - 1) % N  # índice anterior (periódico)
        
        for j in range(N):
            jp = (j + 1) % N
            jm = (j - 1) % N
            
            # Guardar valor anterior
            old_val = phi[i, j]
            
            # Ecuación de diferencias finitas reorganizada para phi[i,j]
            # \nabla²phi = f  →  phi[i,j] = 0.25*(suma_vecinos - dx²*f[i,j])
            phi[i, j] = 0.25 * (phi[ip, j] + phi[im, j] + 
                                phi[i, jp] + phi[i, jm] - 
                                dx*dx * f[i, j])
            
            # Calcular residuo local
            local_res = abs(phi[i, j] - old_val)
            res = max(res, local_res)
    
    # Imprimir progreso
    if it % 500 == 0:
        print(f"Iteración {it:5d}: residuo = {res:.6e}")
    
    it += 1

# Guardar solución final
snapshots[it-1] = phi.copy()
print(f"  Snapshot guardado en iteración {it-1} (Final)")

print("-" * 60)
print(f"\checkConvergencia alcanzada en {it} iteraciones")
print(f"  Residuo final: {res:.6e}")
print(f"  Tolerancia: {tol:.6e}")

# -----------------------
# VISUALIZACIÓN: Evolución temporal (snapshots)
# -----------------------
samp = max(1, N // 80)  # submuestreo para visualización 3D
sorted_iters = sorted(snapshots.keys())
num_snapshots = len(sorted_iters)

# Calcular configuración de subplots
n_cols = 3
n_rows = (num_snapshots + n_cols - 1) // n_cols  # redondeo hacia arriba

fig = plt.figure(figsize=(18, 6*n_rows))

for idx, iter_num in enumerate(sorted_iters):
    ax = fig.add_subplot(n_rows, n_cols, idx+1, projection='3d')
    snapshot = snapshots[iter_num]
    
    # Crear superficie 3D
    surf = ax.plot_surface(X[::samp, ::samp], Y[::samp, ::samp],
                          snapshot[::samp, ::samp], cmap='viridis',
                          linewidth=0, antialiased=True, alpha=0.9,
                          edgecolor='none')
    
    ax.set_xlabel('x', fontsize=10)
    ax.set_ylabel('y', fontsize=10)
    ax.set_zlabel('\phi(x,y)', fontsize=10)
    
    # Título diferenciado para la solución final
    if iter_num == sorted_iters[-1]:
        ax.set_title(f'Iteración {iter_num} (SOLUCIÓN FINAL)\nResiduo: {res:.2e}', 
                    fontsize=12, fontweight='bold', color='green')
    else:
        ax.set_title(f'Iteración {iter_num}', 
                    fontsize=12, fontweight='bold')
    
    # Ajustar vista
    ax.view_init(elev=25, azim=45)
    
    # Barra de color
    cbar = fig.colorbar(surf, ax=ax, shrink=0.5, aspect=10, pad=0.1)
    cbar.set_label('\phi', fontsize=9)
    
    # Información adicional en la primera gráfica
    if idx == 0:
        info_text = f'N = {N}x{N}\ndx = {dx:.4f}\ntol = {tol:.2e}'
        ax.text2D(0.02, 0.98, info_text, transform=ax.transAxes,
                 verticalalignment='top', fontsize=9,
                 bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.7))

plt.suptitle('Evolución de \phi(x,y) - Método de Gauss-Seidel con Condiciones Periódicas',
            fontsize=16, fontweight='bold', y=0.995)
plt.tight_layout()
plt.show()

# -----------------------
# Resumen de resultados
# -----------------------
print("\n" + "="*60)
print("RESUMEN DE RESULTADOS")
print("="*60)
print(f"Parámetros:")
print(f"  - Resolución: {N}x{N}")
print(f"  - Dominio: [0, {Lx:.4f}] x [0, {Ly:.4f}]")
print(f"  - dx = dy = {dx:.6f}")
print(f"\nConvergencia:")
print(f"  - Iteraciones: {it}")
print(f"  - Residuo final: {res:.6e}")
print(f"  - Tolerancia: {tol:.6e}")
print(f"\nSolución \phi(x,y):")
print(f"  - Mínimo: {np.min(phi):.6f}")
print(f"  - Máximo: {np.max(phi):.6f}")
print(f"  - Media: {np.mean(phi):.6f}")
print(f"\nSnapshots guardados en iteraciones: {sorted_iters}")
print("="*60)
\end{python}
\end{document}